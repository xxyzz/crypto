# Week 6 - Programming Assignment

1. Your goal in this project is to break RSA when the public modulus *N* is generated incorrectly. This should serve as yet another reminder not to implement crypto primitives yourself.

    Normally, the primes that comprise an RSA modulus are generated independently of one another. But suppose a developer decides to generate the first prime *p* by choosing a random number *R* and scanning for a prime close by. The second prime *q* is generated by scanning for some other random prime also close to *R*. 

    We show that the resulting RSA modulus *N *= *pq* can be easily factored.

    Suppose you are given a composite *N* and are told that *N* is a product of two relatively close primes *p* and *q*, namely *p* and *q* satisfy

    \|*p* - *q*\| < 2*N*<sup>1/4</sup> (\*)

    Your goal is to factor *N*.

    Let *A* be the arithmetic average of the two primes, that is *A* = (*p* + *q*) / 2. Since *p* and *q* are odd, we know that *p* + *q* is even and therefore *A* is an integer.

    To factor *N* you first observe that under condition (\*) the quantity √*N* is very close to *A*. In particular, we show below that:

    *A* - √*N* < 1

    But since *A* is an integer, rounding √*N* up to the closest integer reveals the value of *A*. In code, *A* = ceil(sqrt(*N*)) where "ceil" is the ceiling function.

    Visually, the numbers *p*, *q*, √*N* and *A* are ordered as follows:

    ```
                       √N
     |                  |   |                           |
    ------------------------------------------------------
     |                  |   |                           |
     p                    A=(p+q)/2                     q
    ```

    Since *A* is the exact mid-point between *p* and *q* there is an integer *x* such that *p* = *A* - *x* and *q* = *A* + *x*.

    But then *N* = *pq* = (*A* - *x*)(*A* + *x*) = *A²* - *x²* and therefore *x* = √(*A²* - *N*).

    Now, given *x* and *A* you can find the factors *p* and *q* of *N* since *p* = *A* - *x* and *q* = *A* + *x*. You have now factored *N*!

    Further reading: the method described above is a greatly simplified version of a much more general [result](https://dl.acm.org/doi/10.5555/1754495.1754517) on factoring when the high order bits of the prime factor are known.

    In the following challenges, you will factor the given moduli using the method outlined above. To solve this assignment it is best to use an environment that supports multi-precision arithmetic and square roots. In Python you could use the [gmpy2](https://gmpy2.readthedocs.io/en/latest/mpz.html#mpz-methods) module. In C you can use [GMP](https://gmplib.org).

    **Factoring challenge #1:**

    The following modulus *N* is a products of two primes *p* and *q* where \|*p* - *q*\| < 2*N*<sup>1/4</sup>. Find the smaller of the two factors and enter it as a decimal integer in the box below.

    ```python
    N = 17976931348623159077293051907890247336179769789423065727343008115 \
    77326758055056206869853794492129829595855013875371640157101398586 \
    47833778606925583497541085196591615128057575940752635007475935288 \
    71082364994994077189561705436114947486504671101510156394068052754 \
    0071584560878577663743040086340742855278549092581
    ```

    For completeness, let us see why *A* - √*N* < 1. This follows from the following simple calculation.

    First observe that *A²* - *N* = ((*p* + *q*)/2)² - *N* = (*p²* + 2*N* + *q²*)/4 - *N* = (*p²* - 2*N* + *q²*)/4 = (*p* - *q*)²/4.

    Now, since for all *x*, *y*: (*x* - *y*)(*x* + *y*) = *x²* - *y²* we obtain *A* - √*N* = (*A* - √*N*)(*A* + √*N*)/(*A* + √*N*) = (*A²* - *N*)/(*A* + √*N*) = ((*p* - *q*)²/4)/(*A* + √*N*).

    Since √*N* ≤ *A* it follows that *A* - √*N* ≤ ((*p* - *q*)²/4)/2√*N* = (*p* - *q*)²/8√*N*.

    By assumption (\*) we know that (*p* - *q*)² < 4√*N* and therefore *A* - √*N* ≤ 4√*N*/8√*N* = 1/2 as required.

2. Factoring challenge #2:

    The following modulus *N* is a products of two primes *p* and *q* where \|*p* - *q*\| < 2<sup>11</sup>*N*<sup>1/4</sup>. Find the smaller of the two factors and enter it as a decimal integer.

    Hint: in this case *A* - √*N* < 2<sup>19</sup> so try scanning for *A* from √*N* upwards, until you succeed in factoring *N*.

    ```python
    N = 6484558428080716696628242653467722787263437207069762630604390703787 \
    9730861808111646271401527606141756919558732184025452065542490671989 \
    2428844841839353281972988531310511738648965962582821502504990264452 \
    1008852816733037111422964210278402893076574586452336833570778346897 \
    15838646088239640236866252211790085787877
    ```

3. Factoring challenge #3:

    The following modulus *N* is a product of two primes *p* and *q* where \|3*p* - 2*q*\| < *N*<sup>1/4</sup>. Find the smaller of the two factors and enter it as a decimal integer.

    Hint: first show that √6*N* is close to (3*p* + 2*q*)/2 and then adapt the method in challenge #1 to factor *N*.

    ```python
    N = 72006226374735042527956443552558373833808445147399984182665305798191 \
    63556901883377904234086641876639384851752649940178970835240791356868 \
    77441155132015188279331812309091996246361896836573643119174094961348 \
    52463970788523879939683923036467667022162701835329944324119217381272 \
    9276147530748597302192751375739387929
    ```
